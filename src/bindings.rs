/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type std_size_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string__Char_alloc_type = [u8; 0usize];
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = [u8; 0usize];
pub type std_basic_string_difference_type = [u8; 0usize];
pub type std_basic_string_reference = [u8; 0usize];
pub type std_basic_string_const_reference = [u8; 0usize];
pub type std_basic_string_pointer = [u8; 0usize];
pub type std_basic_string_const_pointer = [u8; 0usize];
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
#[repr(C)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
pub struct std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: __BindgenUnionField<*mut _CharT>,
    pub _M_allocated_capacity: __BindgenUnionField<std_basic_string_size_type>,
    pub bindgen_union_field: u64,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___or_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
pub type std_conditional_type<_Iftrue> = _Iftrue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug)]
pub struct std___pair_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list<_E> {
    pub _M_array: std_initializer_list_iterator<_E>,
    pub _M_len: std_initializer_list_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_E>>,
}
pub type std_initializer_list_value_type<_E> = _E;
pub type std_initializer_list_reference<_E> = *const _E;
pub type std_initializer_list_const_reference<_E> = *const _E;
pub type std_initializer_list_size_type = std_size_t;
pub type std_initializer_list_iterator<_E> = *const _E;
pub type std_initializer_list_const_iterator<_E> = *const _E;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_input_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_input_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_input_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_input_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_input_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[repr(C)]
#[derive(Debug)]
pub struct std___detail__ReuseOrAllocNode {
    pub _M_nodes: *mut std___detail__ReuseOrAllocNode___node_type,
    pub _M_h: *mut std___detail__ReuseOrAllocNode___hashtable_alloc,
}
pub type std___detail__ReuseOrAllocNode___node_alloc_type<_NodeAlloc> = _NodeAlloc;
pub type std___detail__ReuseOrAllocNode___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std___detail__ReuseOrAllocNode___node_alloc_traits =
    std___detail__ReuseOrAllocNode___hashtable_alloc;
pub type std___detail__ReuseOrAllocNode___node_type =
    std___detail__ReuseOrAllocNode___hashtable_alloc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hash_node_base {
    pub _M_nxt: *mut std___detail__Hash_node_base,
}
#[test]
fn bindgen_test_layout_std___detail__Hash_node_base() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Hash_node_base>(),
        8usize,
        concat!("Size of: ", stringify!(std___detail__Hash_node_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Hash_node_base>(),
        8usize,
        concat!("Alignment of ", stringify!(std___detail__Hash_node_base))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std___detail__Hash_node_base>()))._M_nxt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std___detail__Hash_node_base),
            "::",
            stringify!(_M_nxt)
        )
    );
}
pub type std___detail__Node_iterator_base___node_type = u8;
pub type std___detail__Node_iterator___base_type = u8;
pub type std___detail__Node_iterator___node_type = std___detail__Node_iterator___base_type;
pub type std___detail__Node_iterator_value_type<_Value> = _Value;
pub type std___detail__Node_iterator_difference_type = isize;
pub type std___detail__Node_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Node_iterator_pointer = u8;
pub type std___detail__Node_iterator_reference = u8;
pub type std___detail__Node_const_iterator___base_type = u8;
pub type std___detail__Node_const_iterator___node_type =
    std___detail__Node_const_iterator___base_type;
pub type std___detail__Node_const_iterator_value_type<_Value> = _Value;
pub type std___detail__Node_const_iterator_difference_type = isize;
pub type std___detail__Node_const_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Node_const_iterator_pointer<_Value> = *const _Value;
pub type std___detail__Node_const_iterator_reference<_Value> = *const _Value;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Rehash_base {
    pub _address: u8,
}
pub type std___detail__Local_iterator___base_type = u8;
pub type std___detail__Local_iterator___hash_code_base = std___detail__Local_iterator___base_type;
pub type std___detail__Local_iterator_value_type<_Value> = _Value;
pub type std___detail__Local_iterator_pointer = u8;
pub type std___detail__Local_iterator_reference = u8;
pub type std___detail__Local_iterator_difference_type = isize;
pub type std___detail__Local_iterator_iterator_category = std_forward_iterator_tag;
pub type std___detail__Local_const_iterator___base_type = u8;
pub type std___detail__Local_const_iterator___hash_code_base =
    std___detail__Local_const_iterator___base_type;
pub type std___detail__Local_const_iterator_value_type<_Value> = _Value;
pub type std___detail__Local_const_iterator_pointer<_Value> = *const _Value;
pub type std___detail__Local_const_iterator_reference<_Value> = *const _Value;
pub type std___detail__Local_const_iterator_difference_type = isize;
pub type std___detail__Local_const_iterator_iterator_category = std_forward_iterator_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std____detail___Prime_rehash_policy {
    pub __z: f64,
}
pub type std___detail__Hashtable_base_key_type<_Key> = _Key;
pub type std___detail__Hashtable_base_value_type<_Value> = _Value;
pub type std___detail__Hashtable_base_key_equal<_Equal> = _Equal;
pub type std___detail__Hashtable_base_size_type = std_size_t;
pub type std___detail__Hashtable_base_difference_type = isize;
pub type std___detail__Hashtable_base___traits_type<_Traits> = _Traits;
pub type std___detail__Hashtable_base___hash_cached = [u8; 0usize];
pub type std___detail__Hashtable_base___constant_iterators = [u8; 0usize];
pub type std___detail__Hashtable_base___unique_keys = [u8; 0usize];
pub type std___detail__Hashtable_base___hash_code_base = u8;
pub type std___detail__Hashtable_base___hash_code = std___detail__Hashtable_base___hash_code_base;
pub type std___detail__Hashtable_base___node_type = std___detail__Hashtable_base___hash_code_base;
pub type std___detail__Hashtable_base_iterator = u8;
pub type std___detail__Hashtable_base_const_iterator = u8;
pub type std___detail__Hashtable_base_local_iterator = u8;
pub type std___detail__Hashtable_base_const_local_iterator = u8;
pub type std___detail__Hashtable_base___ireturn_type = u8;
pub type std___detail__Hashtable_base__EqualEBO = u8;
pub type std___detail__Hashtable_base__EqualHelper = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Hashtable_alloc {
    pub _address: u8,
}
pub type std___detail__Hashtable_alloc___ebo_node_alloc = u8;
pub type std___detail__Hashtable_alloc___node_type = [u8; 0usize];
pub type std___detail__Hashtable_alloc___node_alloc_type<_NodeAlloc> = _NodeAlloc;
pub type std___detail__Hashtable_alloc___node_alloc_traits = __gnu_cxx___alloc_traits;
pub type std___detail__Hashtable_alloc___value_alloc_traits = [u8; 0usize];
pub type std___detail__Hashtable_alloc___node_base = std___detail__Hash_node_base;
pub type std___detail__Hashtable_alloc___bucket_type =
    *mut std___detail__Hashtable_alloc___node_base;
pub type std___detail__Hashtable_alloc___bucket_alloc_type = std___alloc_rebind;
pub type std___detail__Hashtable_alloc___bucket_alloc_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_binary_function {
    pub _address: u8,
}
pub type std_binary_function_first_argument_type<_Arg1> = _Arg1;
pub type std_binary_function_second_argument_type<_Arg2> = _Arg2;
pub type std_binary_function_result_type<_Result> = _Result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_equal_to {
    pub _address: u8,
}
pub type std_string = std_basic_string<::std::os::raw::c_char>;
pub type std_streamoff = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
pub type std_streampos = std_fpos<mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = std_size_t;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug)]
pub struct std_hash {
    pub _address: u8,
}
#[repr(C)]
pub struct std__Vector_base {
    pub _M_impl: std__Vector_base__Vector_impl,
}
pub type std__Vector_base__Tp_alloc_type = [u8; 0usize];
pub type std__Vector_base_pointer = [u8; 0usize];
#[repr(C)]
pub struct std__Vector_base__Vector_impl_data {
    pub _M_start: std__Vector_base_pointer,
    pub _M_finish: std__Vector_base_pointer,
    pub _M_end_of_storage: std__Vector_base_pointer,
}
#[repr(C)]
pub struct std__Vector_base__Vector_impl {
    pub _base_1: std__Vector_base__Vector_impl_data,
}
pub type std__Vector_base_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
pub struct std_vector {
    pub _base: std__Vector_base,
}
pub type std_vector__Base = std__Vector_base;
pub type std_vector__Tp_alloc_type = std_vector__Base;
pub type std_vector__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_vector_value_type<_Tp> = _Tp;
pub type std_vector_pointer = std_vector__Base;
pub type std_vector_const_pointer = std_vector__Alloc_traits;
pub type std_vector_reference = std_vector__Alloc_traits;
pub type std_vector_const_reference = std_vector__Alloc_traits;
pub type std_vector_iterator = __gnu_cxx___normal_iterator<std_vector_pointer>;
pub type std_vector_const_iterator = __gnu_cxx___normal_iterator<std_vector_const_pointer>;
pub type std_vector_const_reverse_iterator = std_reverse_iterator<std_vector_const_iterator>;
pub type std_vector_reverse_iterator = std_reverse_iterator<std_vector_iterator>;
pub type std_vector_size_type = std_size_t;
pub type std_vector_difference_type = isize;
pub type std_vector_allocator_type<_Alloc> = _Alloc;
#[repr(C)]
#[derive(Debug)]
pub struct std_vector__Temporary_value {
    pub _M_this: *mut std_vector,
    pub __buf: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std__Hashtable<_RehashPolicy> {
    pub _M_buckets: *mut std__Hashtable___bucket_type,
    pub _M_bucket_count: std__Hashtable_size_type,
    pub _M_before_begin: std__Hashtable___node_base,
    pub _M_element_count: std__Hashtable_size_type,
    pub _M_rehash_policy: _RehashPolicy,
    pub _M_single_bucket: std__Hashtable___bucket_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_RehashPolicy>>,
}
pub type std__Hashtable___traits_type<_Traits> = _Traits;
pub type std__Hashtable___hash_cached = [u8; 0usize];
pub type std__Hashtable___node_type = u8;
pub type std__Hashtable___node_alloc_type = std___alloc_rebind;
pub type std__Hashtable___hashtable_alloc = std___detail__Hashtable_alloc;
pub type std__Hashtable___value_alloc_traits = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___node_alloc_traits = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___node_base = std__Hashtable___hashtable_alloc;
pub type std__Hashtable___bucket_type = std__Hashtable___hashtable_alloc;
pub type std__Hashtable_key_type<_Key> = _Key;
pub type std__Hashtable_value_type<_Value> = _Value;
pub type std__Hashtable_allocator_type<_Alloc> = _Alloc;
pub type std__Hashtable_key_equal<_Equal> = _Equal;
pub type std__Hashtable_pointer = std__Hashtable___value_alloc_traits;
pub type std__Hashtable_const_pointer = std__Hashtable___value_alloc_traits;
pub type std__Hashtable_reference<_Value> = *mut std__Hashtable_value_type<_Value>;
pub type std__Hashtable_const_reference<_Value> = *const std__Hashtable_value_type<_Value>;
pub type std__Hashtable___rehash_type<_RehashPolicy> = _RehashPolicy;
pub type std__Hashtable___rehash_state = [u8; 0usize];
pub type std__Hashtable___constant_iterators = [u8; 0usize];
pub type std__Hashtable___unique_keys = [u8; 0usize];
pub type std__Hashtable___key_extract = u8;
pub type std__Hashtable___hashtable_base = std___detail__Hashtable_base;
pub type std__Hashtable___hash_code_base = std__Hashtable___hashtable_base;
pub type std__Hashtable___hash_code = std__Hashtable___hashtable_base;
pub type std__Hashtable___ireturn_type = std__Hashtable___hashtable_base;
pub type std__Hashtable___map_base = u8;
pub type std__Hashtable___rehash_base = std___detail__Rehash_base;
pub type std__Hashtable___eq_base = u8;
pub type std__Hashtable___reuse_or_alloc_node_type = std___detail__ReuseOrAllocNode;
pub type std__Hashtable___if_hash_cached = std___or_;
pub type std__Hashtable___if_hash_not_cached = std___or_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std__Hashtable___hash_code_base_access {
    pub _address: u8,
}
pub type std__Hashtable_size_type = std__Hashtable___hashtable_base;
pub type std__Hashtable_difference_type = std__Hashtable___hashtable_base;
pub type std__Hashtable_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_const_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_local_iterator = std__Hashtable___hashtable_base;
pub type std__Hashtable_const_local_iterator = std__Hashtable___hashtable_base;
pub type std___uset_hashtable = std__Hashtable<std____detail___Prime_rehash_policy>;
#[repr(C)]
#[derive(Debug)]
pub struct std_unordered_set {
    pub _M_h: std_unordered_set__Hashtable,
}
pub type std_unordered_set__Hashtable = std___uset_hashtable;
pub type std_unordered_set_key_type = std_unordered_set__Hashtable;
pub type std_unordered_set_value_type = std_unordered_set__Hashtable;
pub type std_unordered_set_hasher = std_unordered_set__Hashtable;
pub type std_unordered_set_key_equal = std_unordered_set__Hashtable;
pub type std_unordered_set_allocator_type = std_unordered_set__Hashtable;
pub type std_unordered_set_pointer = std_unordered_set__Hashtable;
pub type std_unordered_set_const_pointer = std_unordered_set__Hashtable;
pub type std_unordered_set_reference = std_unordered_set__Hashtable;
pub type std_unordered_set_const_reference = std_unordered_set__Hashtable;
pub type std_unordered_set_iterator = std_unordered_set__Hashtable;
pub type std_unordered_set_const_iterator = std_unordered_set__Hashtable;
pub type std_unordered_set_local_iterator = std_unordered_set__Hashtable;
pub type std_unordered_set_const_local_iterator = std_unordered_set__Hashtable;
pub type std_unordered_set_size_type = std_unordered_set__Hashtable;
pub type std_unordered_set_difference_type = std_unordered_set__Hashtable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = std_size_t;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator;
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint64_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type mbstate_t = __mbstate_t;
pub type NetworKit_index = u64;
pub type NetworKit_count = u64;
pub type NetworKit_node = NetworKit_index;
pub type NetworKit_edgeweight = f64;
pub type NetworKit_edgeid = NetworKit_index;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetworKit_WeightedEdge {
    pub u: NetworKit_node,
    pub v: NetworKit_node,
    pub weight: NetworKit_edgeweight,
}
#[test]
fn bindgen_test_layout_NetworKit_WeightedEdge() {
    assert_eq!(
        ::std::mem::size_of::<NetworKit_WeightedEdge>(),
        24usize,
        concat!("Size of: ", stringify!(NetworKit_WeightedEdge))
    );
    assert_eq!(
        ::std::mem::align_of::<NetworKit_WeightedEdge>(),
        8usize,
        concat!("Alignment of ", stringify!(NetworKit_WeightedEdge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_WeightedEdge>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_WeightedEdge),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_WeightedEdge>())).v as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_WeightedEdge),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_WeightedEdge>())).weight as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_WeightedEdge),
            "::",
            stringify!(weight)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetworKit_Unsafe {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_NetworKit_Unsafe() {
    assert_eq!(
        ::std::mem::size_of::<NetworKit_Unsafe>(),
        1usize,
        concat!("Size of: ", stringify!(NetworKit_Unsafe))
    );
    assert_eq!(
        ::std::mem::align_of::<NetworKit_Unsafe>(),
        1usize,
        concat!("Alignment of ", stringify!(NetworKit_Unsafe))
    );
}
#[repr(C)]
pub struct NetworKit_Graph {
    pub id: NetworKit_count,
    pub name: std_string,
    pub n: NetworKit_count,
    pub m: NetworKit_count,
    pub storedNumberOfSelfLoops: NetworKit_count,
    pub z: NetworKit_node,
    pub omega: NetworKit_edgeid,
    pub t: NetworKit_count,
    pub weighted: bool,
    pub directed: bool,
    pub edgesIndexed: bool,
    pub exists: [u64; 5usize],
    pub inEdges: std_vector,
    pub outEdges: std_vector,
    pub inEdgeWeights: std_vector,
    pub outEdgeWeights: std_vector,
    pub inEdgeIds: std_vector,
    pub outEdgeIds: std_vector,
}
#[repr(C)]
pub struct NetworKit_Graph_NeighborIterator {
    pub nIter: __gnu_cxx___normal_iterator<const_pointer>,
}
pub type NetworKit_Graph_NeighborIterator_value_type = NetworKit_node;
pub type NetworKit_Graph_NeighborIterator_reference =
    *mut NetworKit_Graph_NeighborIterator_value_type;
pub type NetworKit_Graph_NeighborIterator_pointer =
    *mut NetworKit_Graph_NeighborIterator_value_type;
pub type NetworKit_Graph_NeighborIterator_iterator_category = std_forward_iterator_tag;
pub type NetworKit_Graph_NeighborIterator_difference_type = isize;
pub type NetworKit_Graph_NeighborIterator_self = NetworKit_Graph_NeighborIterator;
#[test]
fn bindgen_test_layout_NetworKit_Graph_NeighborIterator() {
    assert_eq!(
        ::std::mem::size_of::<NetworKit_Graph_NeighborIterator>(),
        8usize,
        concat!("Size of: ", stringify!(NetworKit_Graph_NeighborIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<NetworKit_Graph_NeighborIterator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NetworKit_Graph_NeighborIterator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetworKit_Graph_NeighborIterator>())).nIter as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph_NeighborIterator),
            "::",
            stringify!(nIter)
        )
    );
}
#[repr(C)]
pub struct NetworKit_Graph_NeighborWeightIterator {
    pub nIter: __gnu_cxx___normal_iterator<const_pointer>,
    pub wIter: __gnu_cxx___normal_iterator<const_pointer>,
}
pub type NetworKit_Graph_NeighborWeightIterator_value_type =
    std_pair<NetworKit_node, NetworKit_edgeweight>;
pub type NetworKit_Graph_NeighborWeightIterator_reference =
    *mut NetworKit_Graph_NeighborWeightIterator_value_type;
pub type NetworKit_Graph_NeighborWeightIterator_pointer =
    *mut NetworKit_Graph_NeighborWeightIterator_value_type;
pub type NetworKit_Graph_NeighborWeightIterator_iterator_category = std_forward_iterator_tag;
pub type NetworKit_Graph_NeighborWeightIterator_difference_type = isize;
pub type NetworKit_Graph_NeighborWeightIterator_self = NetworKit_Graph_NeighborWeightIterator;
#[test]
fn bindgen_test_layout_NetworKit_Graph_NeighborWeightIterator() {
    assert_eq!(
        ::std::mem::size_of::<NetworKit_Graph_NeighborWeightIterator>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(NetworKit_Graph_NeighborWeightIterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NetworKit_Graph_NeighborWeightIterator>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NetworKit_Graph_NeighborWeightIterator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetworKit_Graph_NeighborWeightIterator>())).nIter as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph_NeighborWeightIterator),
            "::",
            stringify!(nIter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetworKit_Graph_NeighborWeightIterator>())).wIter as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph_NeighborWeightIterator),
            "::",
            stringify!(wIter)
        )
    );
}
pub type NetworKit_Graph_OutNeighborRange = [u64; 2usize];
pub type NetworKit_Graph_InNeighborRange = [u64; 2usize];
#[test]
fn bindgen_test_layout_NetworKit_Graph() {
    assert_eq!(
        ::std::mem::size_of::<NetworKit_Graph>(),
        280usize,
        concat!("Size of: ", stringify!(NetworKit_Graph))
    );
    assert_eq!(
        ::std::mem::align_of::<NetworKit_Graph>(),
        8usize,
        concat!("Alignment of ", stringify!(NetworKit_Graph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).n as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).m as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<NetworKit_Graph>())).storedNumberOfSelfLoops as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(storedNumberOfSelfLoops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).z as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).omega as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(omega)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).t as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).weighted as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(weighted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).directed as *const _ as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(directed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).edgesIndexed as *const _ as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(edgesIndexed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).exists as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(exists)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).inEdges as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(inEdges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).outEdges as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(outEdges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).inEdgeWeights as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(inEdgeWeights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).outEdgeWeights as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(outEdgeWeights)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).inEdgeIds as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(inEdgeIds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NetworKit_Graph>())).outEdgeIds as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NetworKit_Graph),
            "::",
            stringify!(outEdgeIds)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph21preallocateUndirectedEmm"]
    pub fn NetworKit_Graph_preallocateUndirected(
        this: *mut NetworKit_Graph,
        u: NetworKit_node,
        size: size_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph19preallocateDirectedEmmm"]
    pub fn NetworKit_Graph_preallocateDirected(
        this: *mut NetworKit_Graph,
        u: NetworKit_node,
        outSize: size_t,
        inSize: size_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph10indexEdgesEb"]
    pub fn NetworKit_Graph_indexEdges(this: *mut NetworKit_Graph, force: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph6edgeIdEmm"]
    pub fn NetworKit_Graph_edgeId(
        this: *const NetworKit_Graph,
        u: NetworKit_node,
        v: NetworKit_node,
    ) -> NetworKit_edgeid;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph3typB5cxx11Ev"]
    pub fn NetworKit_Graph_typ(this: *const NetworKit_Graph) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph11shrinkToFitEv"]
    pub fn NetworKit_Graph_shrinkToFit(this: *mut NetworKit_Graph);
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph12compactEdgesEv"]
    pub fn NetworKit_Graph_compactEdges(this: *mut NetworKit_Graph);
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph9sortEdgesEv"]
    pub fn NetworKit_Graph_sortEdges(this: *mut NetworKit_Graph);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph8toStringB5cxx11Ev"]
    pub fn NetworKit_Graph_toString(this: *const NetworKit_Graph) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph9copyNodesEv"]
    pub fn NetworKit_Graph_copyNodes(this: *const NetworKit_Graph) -> NetworKit_Graph;
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph7addNodeEv"]
    pub fn NetworKit_Graph_addNode(this: *mut NetworKit_Graph) -> NetworKit_node;
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph8addNodesEm"]
    pub fn NetworKit_Graph_addNodes(
        this: *mut NetworKit_Graph,
        numberOfNewNodes: NetworKit_count,
    ) -> NetworKit_node;
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph10removeNodeEm"]
    pub fn NetworKit_Graph_removeNode(this: *mut NetworKit_Graph, v: NetworKit_node);
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph11restoreNodeEm"]
    pub fn NetworKit_Graph_restoreNode(this: *mut NetworKit_Graph, v: NetworKit_node);
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph6appendERKS0_"]
    pub fn NetworKit_Graph_append(this: *mut NetworKit_Graph, G: *const NetworKit_Graph);
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph5mergeERKS0_"]
    pub fn NetworKit_Graph_merge(this: *mut NetworKit_Graph, G: *const NetworKit_Graph);
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph17subgraphFromNodesERKSt13unordered_setImSt4hashImESt8equal_toImESaImEEbb"]
    pub fn NetworKit_Graph_subgraphFromNodes(
        this: *const NetworKit_Graph,
        nodes: *const std_unordered_set,
        includeOutNeighbors: bool,
        includeInNeighbors: bool,
    ) -> NetworKit_Graph;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph9maxDegreeEv"]
    pub fn NetworKit_Graph_maxDegree(this: *const NetworKit_Graph) -> NetworKit_count;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph11maxDegreeInEv"]
    pub fn NetworKit_Graph_maxDegreeIn(this: *const NetworKit_Graph) -> NetworKit_count;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph14weightedDegreeEmb"]
    pub fn NetworKit_Graph_weightedDegree(
        this: *const NetworKit_Graph,
        u: NetworKit_node,
        countSelfLoopsTwice: bool,
    ) -> NetworKit_edgeweight;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph17maxWeightedDegreeEv"]
    pub fn NetworKit_Graph_maxWeightedDegree(this: *const NetworKit_Graph) -> NetworKit_edgeweight;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph19maxWeightedDegreeInEv"]
    pub fn NetworKit_Graph_maxWeightedDegreeIn(
        this: *const NetworKit_Graph,
    ) -> NetworKit_edgeweight;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph16weightedDegreeInEmb"]
    pub fn NetworKit_Graph_weightedDegreeIn(
        this: *const NetworKit_Graph,
        u: NetworKit_node,
        countSelfLoopsTwice: bool,
    ) -> NetworKit_edgeweight;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph6volumeEm"]
    pub fn NetworKit_Graph_volume(
        this: *const NetworKit_Graph,
        v: NetworKit_node,
    ) -> NetworKit_edgeweight;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph10randomNodeEv"]
    pub fn NetworKit_Graph_randomNode(this: *const NetworKit_Graph) -> NetworKit_node;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph14randomNeighborEm"]
    pub fn NetworKit_Graph_randomNeighbor(
        this: *const NetworKit_Graph,
        u: NetworKit_node,
    ) -> NetworKit_node;
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph7addEdgeEmmd"]
    pub fn NetworKit_Graph_addEdge(
        this: *mut NetworKit_Graph,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph14addPartialEdgeENS_6UnsafeEmmdm"]
    pub fn NetworKit_Graph_addPartialEdge(
        this: *mut NetworKit_Graph,
        arg1: NetworKit_Unsafe,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
        index: u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph16addPartialInEdgeENS_6UnsafeEmmdm"]
    pub fn NetworKit_Graph_addPartialInEdge(
        this: *mut NetworKit_Graph,
        arg1: NetworKit_Unsafe,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
        index: u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph17addPartialOutEdgeENS_6UnsafeEmmdm"]
    pub fn NetworKit_Graph_addPartialOutEdge(
        this: *mut NetworKit_Graph,
        arg1: NetworKit_Unsafe,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
        index: u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph10removeEdgeEmm"]
    pub fn NetworKit_Graph_removeEdge(
        this: *mut NetworKit_Graph,
        u: NetworKit_node,
        v: NetworKit_node,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph26removeEdgesFromIsolatedSetERKSt6vectorImSaImEE"]
    pub fn NetworKit_Graph_removeEdgesFromIsolatedSet(
        this: *mut NetworKit_Graph,
        nodesInSet: *const std_vector,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph14removeAllEdgesEv"]
    pub fn NetworKit_Graph_removeAllEdges(this: *mut NetworKit_Graph);
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph15removeSelfLoopsEv"]
    pub fn NetworKit_Graph_removeSelfLoops(this: *mut NetworKit_Graph);
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph16removeMultiEdgesEv"]
    pub fn NetworKit_Graph_removeMultiEdges(this: *mut NetworKit_Graph);
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph8swapEdgeEmmmm"]
    pub fn NetworKit_Graph_swapEdge(
        this: *mut NetworKit_Graph,
        s1: NetworKit_node,
        t1: NetworKit_node,
        s2: NetworKit_node,
        t2: NetworKit_node,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph7hasEdgeEmm"]
    pub fn NetworKit_Graph_hasEdge(
        this: *const NetworKit_Graph,
        u: NetworKit_node,
        v: NetworKit_node,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph10randomEdgeEb"]
    pub fn NetworKit_Graph_randomEdge(
        this: *const NetworKit_Graph,
        uniformDistribution: bool,
    ) -> std_pair<NetworKit_node, NetworKit_node>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph11randomEdgesEm"]
    pub fn NetworKit_Graph_randomEdges(
        this: *const NetworKit_Graph,
        nr: NetworKit_count,
    ) -> std_vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph4sizeEv"]
    pub fn NetworKit_Graph_size(
        this: *const NetworKit_Graph,
    ) -> std_pair<NetworKit_count, NetworKit_count>;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph7densityEv"]
    pub fn NetworKit_Graph_density(this: *const NetworKit_Graph) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph16checkConsistencyEv"]
    pub fn NetworKit_Graph_checkConsistency(this: *const NetworKit_Graph) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph6weightEmm"]
    pub fn NetworKit_Graph_weight(
        this: *const NetworKit_Graph,
        u: NetworKit_node,
        v: NetworKit_node,
    ) -> NetworKit_edgeweight;
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph9setWeightEmmd"]
    pub fn NetworKit_Graph_setWeight(
        this: *mut NetworKit_Graph,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5Graph14increaseWeightEmmd"]
    pub fn NetworKit_Graph_increaseWeight(
        this: *mut NetworKit_Graph,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph15totalEdgeWeightEv"]
    pub fn NetworKit_Graph_totalEdgeWeight(this: *const NetworKit_Graph) -> NetworKit_edgeweight;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph5nodesEv"]
    pub fn NetworKit_Graph_nodes(this: *const NetworKit_Graph) -> std_vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph5edgesEv"]
    pub fn NetworKit_Graph_edges(this: *const NetworKit_Graph) -> std_vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph9neighborsEm"]
    pub fn NetworKit_Graph_neighbors(this: *const NetworKit_Graph, u: NetworKit_node)
        -> std_vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph12toUndirectedEv"]
    pub fn NetworKit_Graph_toUndirected(this: *const NetworKit_Graph) -> NetworKit_Graph;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph12toUnweightedEv"]
    pub fn NetworKit_Graph_toUnweighted(this: *const NetworKit_Graph) -> NetworKit_Graph;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9NetworKit5Graph9transposeEv"]
    pub fn NetworKit_Graph_transpose(this: *const NetworKit_Graph) -> NetworKit_Graph;
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5GraphC1Embb"]
    pub fn NetworKit_Graph_Graph(
        this: *mut NetworKit_Graph,
        n: NetworKit_count,
        weighted: bool,
        directed: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5GraphC1ERKS0_bb"]
    pub fn NetworKit_Graph_Graph1(
        this: *mut NetworKit_Graph,
        G: *const NetworKit_Graph,
        weighted: bool,
        directed: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN9NetworKit5GraphC1ESt16initializer_listINS_12WeightedEdgeEE"]
    pub fn NetworKit_Graph_Graph2(
        this: *mut NetworKit_Graph,
        edges: std_initializer_list<NetworKit_WeightedEdge>,
    );
}
impl NetworKit_Graph {
    #[inline]
    pub unsafe fn preallocateUndirected(&mut self, u: NetworKit_node, size: size_t) {
        NetworKit_Graph_preallocateUndirected(self, u, size)
    }
    #[inline]
    pub unsafe fn preallocateDirected(
        &mut self,
        u: NetworKit_node,
        outSize: size_t,
        inSize: size_t,
    ) {
        NetworKit_Graph_preallocateDirected(self, u, outSize, inSize)
    }
    #[inline]
    pub unsafe fn indexEdges(&mut self, force: bool) {
        NetworKit_Graph_indexEdges(self, force)
    }
    #[inline]
    pub unsafe fn edgeId(&self, u: NetworKit_node, v: NetworKit_node) -> NetworKit_edgeid {
        NetworKit_Graph_edgeId(self, u, v)
    }
    #[inline]
    pub unsafe fn typ(&self) -> std_string {
        NetworKit_Graph_typ(self)
    }
    #[inline]
    pub unsafe fn shrinkToFit(&mut self) {
        NetworKit_Graph_shrinkToFit(self)
    }
    #[inline]
    pub unsafe fn compactEdges(&mut self) {
        NetworKit_Graph_compactEdges(self)
    }
    #[inline]
    pub unsafe fn sortEdges(&mut self) {
        NetworKit_Graph_sortEdges(self)
    }
    #[inline]
    pub unsafe fn toString(&self) -> std_string {
        NetworKit_Graph_toString(self)
    }
    #[inline]
    pub unsafe fn copyNodes(&self) -> NetworKit_Graph {
        NetworKit_Graph_copyNodes(self)
    }
    #[inline]
    pub unsafe fn addNode(&mut self) -> NetworKit_node {
        NetworKit_Graph_addNode(self)
    }
    #[inline]
    pub unsafe fn addNodes(&mut self, numberOfNewNodes: NetworKit_count) -> NetworKit_node {
        NetworKit_Graph_addNodes(self, numberOfNewNodes)
    }
    #[inline]
    pub unsafe fn removeNode(&mut self, v: NetworKit_node) {
        NetworKit_Graph_removeNode(self, v)
    }
    #[inline]
    pub unsafe fn restoreNode(&mut self, v: NetworKit_node) {
        NetworKit_Graph_restoreNode(self, v)
    }
    #[inline]
    pub unsafe fn append(&mut self, G: *const NetworKit_Graph) {
        NetworKit_Graph_append(self, G)
    }
    #[inline]
    pub unsafe fn merge(&mut self, G: *const NetworKit_Graph) {
        NetworKit_Graph_merge(self, G)
    }
    #[inline]
    pub unsafe fn subgraphFromNodes(
        &self,
        nodes: *const std_unordered_set,
        includeOutNeighbors: bool,
        includeInNeighbors: bool,
    ) -> NetworKit_Graph {
        NetworKit_Graph_subgraphFromNodes(self, nodes, includeOutNeighbors, includeInNeighbors)
    }
    #[inline]
    pub unsafe fn maxDegree(&self) -> NetworKit_count {
        NetworKit_Graph_maxDegree(self)
    }
    #[inline]
    pub unsafe fn maxDegreeIn(&self) -> NetworKit_count {
        NetworKit_Graph_maxDegreeIn(self)
    }
    #[inline]
    pub unsafe fn weightedDegree(
        &self,
        u: NetworKit_node,
        countSelfLoopsTwice: bool,
    ) -> NetworKit_edgeweight {
        NetworKit_Graph_weightedDegree(self, u, countSelfLoopsTwice)
    }
    #[inline]
    pub unsafe fn maxWeightedDegree(&self) -> NetworKit_edgeweight {
        NetworKit_Graph_maxWeightedDegree(self)
    }
    #[inline]
    pub unsafe fn maxWeightedDegreeIn(&self) -> NetworKit_edgeweight {
        NetworKit_Graph_maxWeightedDegreeIn(self)
    }
    #[inline]
    pub unsafe fn weightedDegreeIn(
        &self,
        u: NetworKit_node,
        countSelfLoopsTwice: bool,
    ) -> NetworKit_edgeweight {
        NetworKit_Graph_weightedDegreeIn(self, u, countSelfLoopsTwice)
    }
    #[inline]
    pub unsafe fn volume(&self, v: NetworKit_node) -> NetworKit_edgeweight {
        NetworKit_Graph_volume(self, v)
    }
    #[inline]
    pub unsafe fn randomNode(&self) -> NetworKit_node {
        NetworKit_Graph_randomNode(self)
    }
    #[inline]
    pub unsafe fn randomNeighbor(&self, u: NetworKit_node) -> NetworKit_node {
        NetworKit_Graph_randomNeighbor(self, u)
    }
    #[inline]
    pub unsafe fn addEdge(
        &mut self,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
    ) {
        NetworKit_Graph_addEdge(self, u, v, ew)
    }
    #[inline]
    pub unsafe fn addPartialEdge(
        &mut self,
        arg1: NetworKit_Unsafe,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
        index: u64,
    ) {
        NetworKit_Graph_addPartialEdge(self, arg1, u, v, ew, index)
    }
    #[inline]
    pub unsafe fn addPartialInEdge(
        &mut self,
        arg1: NetworKit_Unsafe,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
        index: u64,
    ) {
        NetworKit_Graph_addPartialInEdge(self, arg1, u, v, ew, index)
    }
    #[inline]
    pub unsafe fn addPartialOutEdge(
        &mut self,
        arg1: NetworKit_Unsafe,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
        index: u64,
    ) {
        NetworKit_Graph_addPartialOutEdge(self, arg1, u, v, ew, index)
    }
    #[inline]
    pub unsafe fn removeEdge(&mut self, u: NetworKit_node, v: NetworKit_node) {
        NetworKit_Graph_removeEdge(self, u, v)
    }
    #[inline]
    pub unsafe fn removeEdgesFromIsolatedSet(&mut self, nodesInSet: *const std_vector) {
        NetworKit_Graph_removeEdgesFromIsolatedSet(self, nodesInSet)
    }
    #[inline]
    pub unsafe fn removeAllEdges(&mut self) {
        NetworKit_Graph_removeAllEdges(self)
    }
    #[inline]
    pub unsafe fn removeSelfLoops(&mut self) {
        NetworKit_Graph_removeSelfLoops(self)
    }
    #[inline]
    pub unsafe fn removeMultiEdges(&mut self) {
        NetworKit_Graph_removeMultiEdges(self)
    }
    #[inline]
    pub unsafe fn swapEdge(
        &mut self,
        s1: NetworKit_node,
        t1: NetworKit_node,
        s2: NetworKit_node,
        t2: NetworKit_node,
    ) {
        NetworKit_Graph_swapEdge(self, s1, t1, s2, t2)
    }
    #[inline]
    pub unsafe fn hasEdge(&self, u: NetworKit_node, v: NetworKit_node) -> bool {
        NetworKit_Graph_hasEdge(self, u, v)
    }
    #[inline]
    pub unsafe fn randomEdge(
        &self,
        uniformDistribution: bool,
    ) -> std_pair<NetworKit_node, NetworKit_node> {
        NetworKit_Graph_randomEdge(self, uniformDistribution)
    }
    #[inline]
    pub unsafe fn randomEdges(&self, nr: NetworKit_count) -> std_vector {
        NetworKit_Graph_randomEdges(self, nr)
    }
    #[inline]
    pub unsafe fn size(&self) -> std_pair<NetworKit_count, NetworKit_count> {
        NetworKit_Graph_size(self)
    }
    #[inline]
    pub unsafe fn density(&self) -> f64 {
        NetworKit_Graph_density(self)
    }
    #[inline]
    pub unsafe fn checkConsistency(&self) -> bool {
        NetworKit_Graph_checkConsistency(self)
    }
    #[inline]
    pub unsafe fn weight(&self, u: NetworKit_node, v: NetworKit_node) -> NetworKit_edgeweight {
        NetworKit_Graph_weight(self, u, v)
    }
    #[inline]
    pub unsafe fn setWeight(
        &mut self,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
    ) {
        NetworKit_Graph_setWeight(self, u, v, ew)
    }
    #[inline]
    pub unsafe fn increaseWeight(
        &mut self,
        u: NetworKit_node,
        v: NetworKit_node,
        ew: NetworKit_edgeweight,
    ) {
        NetworKit_Graph_increaseWeight(self, u, v, ew)
    }
    #[inline]
    pub unsafe fn totalEdgeWeight(&self) -> NetworKit_edgeweight {
        NetworKit_Graph_totalEdgeWeight(self)
    }
    #[inline]
    pub unsafe fn nodes(&self) -> std_vector {
        NetworKit_Graph_nodes(self)
    }
    #[inline]
    pub unsafe fn edges(&self) -> std_vector {
        NetworKit_Graph_edges(self)
    }
    #[inline]
    pub unsafe fn neighbors(&self, u: NetworKit_node) -> std_vector {
        NetworKit_Graph_neighbors(self, u)
    }
    #[inline]
    pub unsafe fn toUndirected(&self) -> NetworKit_Graph {
        NetworKit_Graph_toUndirected(self)
    }
    #[inline]
    pub unsafe fn toUnweighted(&self) -> NetworKit_Graph {
        NetworKit_Graph_toUnweighted(self)
    }
    #[inline]
    pub unsafe fn transpose(&self) -> NetworKit_Graph {
        NetworKit_Graph_transpose(self)
    }
    #[inline]
    pub unsafe fn new(n: NetworKit_count, weighted: bool, directed: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        NetworKit_Graph_Graph(__bindgen_tmp.as_mut_ptr(), n, weighted, directed);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(G: *const NetworKit_Graph, weighted: bool, directed: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        NetworKit_Graph_Graph1(__bindgen_tmp.as_mut_ptr(), G, weighted, directed);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(edges: std_initializer_list<NetworKit_WeightedEdge>) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        NetworKit_Graph_Graph2(__bindgen_tmp.as_mut_ptr(), edges);
        __bindgen_tmp.assume_init()
    }
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_bool__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_vector_open1_NetworKit_node_std_allocator_open2_unsigned_long_close2_close1_std_allocator_open1_std_vector_open2_unsigned_long_std_allocator_open3_unsigned_long_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NetworKit_node_std_allocator_open1_unsigned_long_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_unsigned_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_vector_open1_unsigned_long_std_allocator_open2_unsigned_long_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_unsigned_long_std_allocator_open1_unsigned_long_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_unsigned_long_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_vector_open1_NetworKit_node_std_allocator_open2_unsigned_long_close2_close1_std_allocator_open1_std_vector_open2_unsigned_long_std_allocator_open3_unsigned_long_close3_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NetworKit_node_std_allocator_open1_unsigned_long_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_unsigned_long_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_vector_open1_unsigned_long_std_allocator_open2_unsigned_long_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_unsigned_long_std_allocator_open1_unsigned_long_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_unsigned_long_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_vector_open1_NetworKit_edgeweight_std_allocator_open2_double_close2_close1_std_allocator_open1_std_vector_open2_double_std_allocator_open3_double_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NetworKit_edgeweight_std_allocator_open1_double_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_vector_open1_double_std_allocator_open2_double_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_double_std_allocator_open1_double_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_double_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_vector_open1_NetworKit_edgeweight_std_allocator_open2_double_close2_close1_std_allocator_open1_std_vector_open2_double_std_allocator_open3_double_close3_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NetworKit_edgeweight_std_allocator_open1_double_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_double_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_vector_open1_double_std_allocator_open2_double_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_double_std_allocator_open1_double_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_double_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_vector_open1_NetworKit_edgeid_std_allocator_open2_unsigned_long_close2_close1_std_allocator_open1_std_vector_open2_unsigned_long_std_allocator_open3_unsigned_long_close3_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NetworKit_edgeid_std_allocator_open1_unsigned_long_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_unsigned_long_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_vector_open1_unsigned_long_std_allocator_open2_unsigned_long_close2_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_unsigned_long_std_allocator_open1_unsigned_long_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_unsigned_long_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_std_vector_open1_NetworKit_edgeid_std_allocator_open2_unsigned_long_close2_close1_std_allocator_open1_std_vector_open2_unsigned_long_std_allocator_open3_unsigned_long_close3_close2_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_NetworKit_edgeid_std_allocator_open1_unsigned_long_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_unsigned_long_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_std_vector_open1_unsigned_long_std_allocator_open2_unsigned_long_close2_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_unsigned_long_std_allocator_open1_unsigned_long_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_unsigned_long_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
pub type const_pointer = *const ::std::os::raw::c_ulong;
#[test]
fn __bindgen_test_layout___gnu_cxx___normal_iterator_open0_const_pointer_std_vector_open1_unsigned_long_std_allocator_open2_unsigned_long_close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<__gnu_cxx___normal_iterator<const_pointer>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(__gnu_cxx___normal_iterator<const_pointer>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gnu_cxx___normal_iterator<const_pointer>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(__gnu_cxx___normal_iterator<const_pointer>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_vector_open0_unsigned_long_std_allocator_open1_unsigned_long_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<std_vector>(),
        24usize,
        concat!("Size of template specialization: ", stringify!(std_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<std_vector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_vector)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_unsigned_long_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_pair_open0_NetworKit_node_NetworKit_edgeweight_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_pair<NetworKit_node, NetworKit_edgeweight>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! ( std_pair < NetworKit_node , NetworKit_edgeweight > )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_pair<NetworKit_node, NetworKit_edgeweight>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! ( std_pair < NetworKit_node , NetworKit_edgeweight > )
        )
    );
}
